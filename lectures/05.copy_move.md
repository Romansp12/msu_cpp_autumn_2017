### Argument-dependent name lookup (ADL)

Известен также, как Koenig lookup.

```c++
namespace X
{
    struct A
    {
        ...
    };
    
    std::ostream& operator<<(std::ostream& out, const A& value)
    {
        ...
    }
}

A a;

std::cout << a;
```

Компилятор ищет метод в текущем пространстве имен и если не находит, то в пространствах имен аргументов.


### Методы генерируемые компилятором неявно

```c++
struct A
{
    X x;
    Y y;

    // Конструктор
    A()
        : x(X())
        , y(Y())
    {
    }
    
    // Деструктор
    ~A()
    {
    }
    
    // Копирующий конструктор
    // A a1;
    // A a2 = a1;
    A(const A& copied)
        : x(copied.x)
        , y(copied.y)
    {
    }
    
    // Оператор копирования
    // A a1;
    // A a2;
    // a2 = a1;
    A& operator=(const A& copied)
    {
        x = copied.x;
        y = copied.y;
        return *this;
    }
    
    // Перемещающий конструктор
    // A a1;
    // A a2 = std::move(a1);
    A(A&& movied)
        : x(std::move(movied.x))
        , y(std::move(movied.y))
    {
    }
    
    // Оператор перемещения
    // A a1;
    // A a2;
    // a2 = std::move(a1);
    A& operator=(A&& movied)
    {
        x = std::move(movied.x);
        y = std::move(movied.y);
        return *this;
    }
};
```

### lvalue и rvalue

> "Объект - это некоторая **именованная область памяти**; lvalue - это выражение, обозначающее объект. Термин "lvalue" произошел от записи присваивания Е1 = Е2, в которой левый (left - левый(англ.), отсюда буква l, value - значение) операнд Е1 должен быть выражением lvalue."

*Керниган и Ритчи*

Если можно взять адрес - lvalue.

```c++
int a = 3; // a - lvalue
int* pa = &a;
```

То что справа - rvalue?

```c++
int& b = a;
```

```c++
void foo(int) {}
void foo(int&) {}
void foo(int&&) {}
```
```c++
void foo(int) {} // <-- этот?
void foo(int&) {} //  // <-- этот?
void foo(int&&) {}

int x = 1;
foo(x);
```
```c++
void foo(int) {} // <-- этот?
void foo(int&) {} // <-- или этот?
void foo(int&&) {}

int x = 1;
int& y = x;
foo(y);
```
```c++
void foo(int) {} // <-- этот?
void foo(int&) {}
void foo(int&&) {} // <-- или этот?

foo(1);
```
```c++
int bar() { return 1; }

void foo(int) {} // <-- этот?
void foo(int&) {} // <-- или этот?
void foo(int&&) {}

foo(bar());
```
```c++
void foo(int) {} // <-- этот?
void foo(int&) {} // <-- или этот?
void foo(int&&) {}

foo(1 + 2);
```

rvalue - это выражения, обозначающие временные объекты:
- результат вызова функций, возвращающих объекты не по ссылке
- результат встроенных операций + - * / и т.п.
- встроенные постфиксные операции i++ i--
- явное создание временной переменной int() или T()

Также rvalue - литералы, кроме строковых (у строковых литералов есть адрес).

### 






















