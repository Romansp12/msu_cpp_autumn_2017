# Агрегация данных

Информация о пользователе:
1. Имя
2. Дата рождения
3. email

##### Без агрегации
```c++
std::string name;
time_t birthDate;
std::string email;
```
##### Много пользователей
```c++
std::string name[];
time_t birthDate[];
std::string email[];
```
##### Агрегируем данные
```c++
struct UserInfo
{
    std::string name;
    time_t birthDate;
    std::string email;
};
```
##### Много пользователей (array of structs)
```c++
UserInfo users[];
```
##### Много пользователей (struct of arrays)
```c++
struct UserInfo
{
    std::string name[];
    time_t birthDate[];
    std::string email[];
};
```
### Класс
Описание сущности и правила взаимодействия с ней.

### struct vs class
В С++ struct от class отличаются только модификатором доступа по-умолчанию. По-умолчанию содержимое struct доступно извне (public), а содержимое class - нет (private).

### Модификаторы доступа
```c++
class A
{
public:
    int x; // Доступно всем
protected:
    int y; // Наследникам и самому себе
private:
    int z; // Только себе
};
```

### Функции внутри классов
Функции внутри классов называются методами.
```c
struct File
{
    int descriptor;
    char* fileName;
    char buffer[BufferSize];
};

File* openFile(char* fileName)
{
    File* file = (File*) malloc(sizeof(File));
    file->descriptor = open(fileName, O_CREAT);
    ...
    return file;
}

void write(File* file, char* data, size_t size)
{
    ...
}

void close(File* file)
{
    close(file->descriptor);
    free(file);
}

File* file = openFile("...");
write(file, data, size);
close(file);
```
```c++
class File
{
public:
    File(const std::string& fileName)
    {
        ...
    }
    
    void write(const char* data, size_t size)
    {
        ...
    }
    
    ~File()
    {
        ...
    }
    
private:
    std::string fileName;
    int descriptor;
    char buffer[BufferSize];
};

File file("...");
file.write(data, size);
```

### Указатель на экземпляр класса
```c++
void write([File* this], const char* data, size_t size)
{
    this->descriptor
}
```
```c++
File* file = nullptr;
file->write(data, size);
```

### Конструктор (ctor)
Служит для инициализации объекта.

Если конструктор не написан явно, С++ гарантирует, что будет создан конструктор по умолчанию.

### Деструктор (dtor)
Служит для деинициализации объекта, **гарантированно вызыватся при удалении объекта**.

Если деструктор не написан явно, С++ гарантирует, что будет создан деструктор по умолчанию.

### RAII (Resource Acquire Is Initialization)
Захват ресурса есть инициализация.

В конструкторе объект получает доступ к какому либо ресурсу (например, открывается файл), а при вызове деструктура этот ресурс освобождается (закрывается файл).

> Можно использовать не только для управления ресурсами



# POD (Plain Old Data)

1. Скалярные типы (bool, числа, указатели, перечисления (enum), nullptr_t)
2. class или struct которые:
    - Имеют только тривиальные конструктор, деструктор, конструктор копирования
    - Нет виртуальных функций и базового класса
    - Нет нестатических полей с модификатором доступа private или public
    - Не содержит статических полей не POD типа














