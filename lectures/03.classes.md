# Агрегация данных

Информация о пользователе:
1. Имя
2. Дата рождения
3. email

##### Без агрегации
```c++
std::string name;
time_t birthDate;
std::string email;
```
##### Много пользователей
```c++
std::string name[];
time_t birthDate[];
std::string email[];
```
##### Агрегируем данные
```c++
struct UserInfo
{
    std::string name;
    time_t birthDate;
    std::string email;
};
```
##### Много пользователей (array of structs)
```c++
UserInfo users[];
```
##### Много пользователей (struct of arrays)
```c++
struct UserInfo
{
    std::string name[];
    time_t birthDate[];
    std::string email[];
};
```
### Класс
Описание сущности и правила взаимодействия с ней.

### Объект (экземпляр класса)
Сущность в адресном пространстве компьютера, появляющаяся
при создании класса.

### struct vs class
В С++ struct от class отличаются только модификатором доступа по-умолчанию. По-умолчанию содержимое struct доступно извне (public), а содержимое class - нет (private).

### Поле класса
Переменная связанная с классом или объектом.

### Модификаторы доступа
```c++
class A
{
public:
    int x; // Доступно всем
protected:
    int y; // Наследникам и объектам класса
private:
    int z; // Только объектам класса
};
```

### Функции внутри классов
Функции внутри классов называются методами.
```c
struct File
{
    int descriptor;
    char* fileName;
    char buffer[BufferSize];
};

File* openFile(char* fileName)
{
    File* file = (File*) malloc(sizeof(File));
    file->descriptor = open(fileName, O_CREAT);
    ...
    return file;
}

void write(File* file, char* data, size_t size)
{
    ...
}

void close(File* file)
{
    close(file->descriptor);
    free(file);
}

File* file = openFile("...");
write(file, data, size);
close(file);
```
```c++
class File
{
public:
    File(const std::string& fileName)
    {
        ...
    }
    
    void write(const char* data, size_t size)
    {
        ...
    }
    
    ~File()
    {
        ...
    }
    
private:
    std::string fileName;
    int descriptor;
    char buffer[BufferSize];
};

File file("...");
file.write(data, size);
```

### Константные методы
```c++
class Thermostat
{
public:
    using Celsius = double;
    
    void setTemperature(Celsius value)
    {
        temperature_ = value;
    }
    
    Celsius getTemperature() const
    {
        return temperature_;
    }
    
private:
    Celsius temperature_;
};
```
```c++
const Thermostat& getThermostat()
{
   ...
}

getThermostat().setTemperature(1000); // Ошибка!
```

### mutable
```c++
class Log
{
    void write(const std::string& text);
};

class Thermostat
{
public:
    using Celsius = double;
    
    Celsius getTemperature() const
    {
        log_.write("...");
        return temperature_;
    }
    
private:
    Celsius temperature_;
    Log log_;
};
```
```c++
class Thermostat
{
    mutable Log log_;
};
```

### Интерфейс класса
Методы класса, доступные для использования другими классами представляют его интерфейс.

### Указатель на экземпляр класса
```c++
void write([File* this], const char* data, size_t size)
{
    this->descriptor
}
```
```c++
File* file = nullptr;
file->write(data, size);
```

### Конструктор (ctor)
Служит для инициализации объекта.

Если конструктор не написан явно, С++ гарантирует, что будет создан конструктор по умолчанию.

### Деструктор (dtor)
Служит для деинициализации объекта, **гарантированно вызыватся при удалении объекта**.

Если деструктор не написан явно, С++ гарантирует, что будет создан деструктор по умолчанию.

### RAII (Resource Acquire Is Initialization)
Захват ресурса есть инициализация.

В конструкторе объект получает доступ к какому либо ресурсу (например, открывается файл), а при вызове деструктура этот ресурс освобождается (закрывается файл).

> Можно использовать не только для управления ресурсами

### Наследование
Возможность порождать класс на основе другого с сохранением всех свойств класса-предка.

Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс – потомком, наследником, дочерним или производным классом.

```c++
class Shape
{
    int x;
    int y;
};

class Circle
    : public Shape
{
    int radius;
};
```

> Наследование моделирует отношение «является».

> Требуется для создания иерархичности – свойства реального мира.

### Композиция
```c++
class Car
{
    Engine engine;
    Wheels wheels[4];
};
```
> Композиция моделирует отношение «содержит/является частью»

# Конструирование объекта
Порядок конструирования:
1. Выделяется память под объект
2. Инициализируются поля класса в том порядке, в котором они объявлены в классе
3. Происходит вызов конструктора
4. Если есть базовые классы, то конструирование начинается с них в порядке их очередности в списке наследования

```c++
class A
{
public:
    A() {} // 3
    ~A() {}

private:
    int x; // 1
    int y; // 2
};

class B
    : public A
{
public:
    B() {} // 5
    ~B() {}

private:
    int z; // 4
};
```

Порядок уничтожения:
1. Происходит вызов деструктора
2. Вызываются деструкторы для полей класса порядке обратном их объявлению в классе
3. Уничтожаются базовые классы в порядке обратном списку наследования

```c++
class A
{
public:
    A() {} // 3
    ~A() {}

private:
    int x; // 5
    int y; // 4
};

class B
    : public A
{
public:
    B() {}
    ~B() {} // 1

private:
    int z; // 2
};
```

### Списки инициализации
```c++
class A
{
    A()
        : x(5)
        , y(6)
    {
        z = 7;
    }
    
    int x;
    int y;
    int z;
};
```

Распространенная ошибка:
```c++
class A
{
    A()
        : y(5) // Инициализация в порядке объявления в классе!
        , x(y)
    {
    }
    
    int x;
    int y;
};
```

### Инициализация в объявлении
```c++
class A
{
    int x = 3;
};
```

# Простые типы (POD, Plain Old Data)

1. Скалярные типы (bool, числа, указатели, перечисления (enum), nullptr_t)
2. class или struct которые:
    - Имеют только тривиальные (сгенерированные компилятором) конструктор, деструктор, конструктор копирования
    - Нет виртуальных функций и базового класса
    - Нет нестатических полей с модификатором доступа private или public
    - Не содержит статических полей не POD типа

#### Особенности:
1. Предсказуемое размещение в памяти
2. Отсутствие управляющего кода

### Примеры
```c+ +
class NotPOD
{
public:
    NotPOD(int x)
    {
    }
};
```
```c+ +
class NotPOD
    : public Base
{
};
```
```c+ +
class NotPOD
{
    virtual void f()
    {
    }
};
```
```c+ +
class NotPOD
{
    int x;
};
```
```c+ +
```
```c+ +
class POD
{
public:
    NotPOD m1;
    int m2;
    static double m3;
private:
    void f() {}
};
```
 
### Предсказуемое размещение в памяти

Порядок размещения полей POD типа в памяти соответствует порядку в котором поля были объявлены.

```c++
class POD
{
public:
    char m1;
    double m2;
};

std::cout << offsetof(POD, m1) << std::endl; // 0
std::cout << offsetof(POD, m2) << std::endl; // 8
std::cout << sizeof(POD) << std::endl; // 16
```
> POD типы можно использовать для передачи из программы в программу, записи на диск и т.д. Но только на одной и той-же платформе!

### Выравнивание полей

В целях повышения быстродействия данные в памяти распологаются по адресам кратным размеру машинного слова (как правило).

```
[         char         ][        double        ]
[c][0][0][0][0][0][0][0][d][d][d][d][d][d][d][d]
```
Выравниванием можно управлять:
```c++
#pragma pack(push, 1)
class POD
{
public:
    char m1;
    double m2;
};
#pragma pack(pop)

std::cout << offsetof(POD, m1) << std::endl; // 0
std::cout << offsetof(POD, m2) << std::endl; // 1
std::cout << sizeof(POD) << std::endl; // 9
```
> Работать будет не всегда, компилятор может это проигнорировать, если посчитает, что сделать это нельзя

Предпочтительное выравнивание можно узнать:
```c++
std::cout << alignof(char) << std::endl; // 1
std::cout << alignof(double) << std::endl; // 8
```

### Оптимизация размера POD структур
```c++
struct POD
{
    int x;
    double y;
    int z;
};

std::cout << sizeof(POD) << std::endl; // 24
```
```c++
struct POD
{
    double y;
    int x;
    int z;
};

std::cout << sizeof(POD) << std::endl; // 16
```

### Отсутствие управляющего кода

Для объекта не требуется вызов конструктора, деструктора, копирующего конструктора.

Отсюда следует:
1. Объекты можно инициализировать статически
2. Копирование – просто копирование памяти (memcpy)

### Инициализация POD типов

```c++
struct POD
{
    int x;
    double y;
};
```
Инициализация нулем (zero-initialization):
```c++
POD p1 = POD();
POD p2 {};
POD* p3 = new POD();

// x == 0
// y == 0
```
Инициализация по умолчанию (default-initialization):

```c++
POD p1;
POD* p2 = new POD;

// x, y содержат мусор
```

### Практическая часть

Рефакторим калькулятор!
1. Делаем класс, теперь вместо передачи результата через функции можно использовать поля класса
2. Добавляем скобки ( )
3. Добавляем константы, например Pi

Пример выражений:
```
(5 + 3 * (8 / Pi) * 4) + (1)
```

Из контант пусть пока будет только Pi (3.14) и e (2.7). Для констант можно использовать std::unordered_map:
```c++
#include <unordered_map>

std::unordered_map<std::string, double> contants = 
    {
        { "Pi", 3.14 },
        { "e", 2.7 }
    };
```


EOF