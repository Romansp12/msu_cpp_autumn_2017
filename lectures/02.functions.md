# Компиляция и компоновка

### Препроцессор
##### Включение файла
```c++
#include <file_name> // Поиск в системных директориях
#include "file_name" // Поиск в текущей директории
```

##### Макроподстановки
```c++
#define true false // happy debugging
#define true !!(rand() % 2)
```
```c++
#define BUF_SIZE 1024
```
Не используйте define для определения констант, он игнорирует пространства имен и ничего не знает о типах.

###### Константы в С++
```c++
namespace options
{
    const size_t BufSize = 1024;
    constexpr size_t BufSize = 1024;
}

std::array<char, options::BufSize> data;
```

##### Условная компиляция
```c++
#define DEBUG
#ifdef DEBUG
    ...
#else
    ...
#endif
```
```
g++ -DDEBUG ...
```

##### Вывод сообщений
```c++
#ifdef BUF_SIZE
#error Rename the macros
#endif

#define BUF_SIZE 256

...

#undef BUF_SIZE
```

### Единица трансляции
Минимальный блок исходного текста, который можно преобразовать во внутреннее машинное представление.

```code.cpp```
```c++
#include <vector>

#include "code.h"

void someFunction()
{
    ...
}

...
```
> Исходный код code.cpp, плюс все включенные в него файлы – единица трансляции.

```
g++ –o code.o –c code.cpp
```
code.o – результат компиляции, объектный файл (object file).

>При изменении любого включенного заголовочного файла потребуется перекомпиляция единицы трансляции.

### Компоновка (linking)
Объектный файл может ссылаться на символы не определенные в нем.

Объектные файлы собираются в исполняемый файл или библиотеку компоновщиком, не определенные символы компоновщик ищет в других объектных файлах и производит их замену на корректные адреса.

```
g++ -o my_app a.o b.o
```

Компоновщик ld, но g++ сделает его вызов самостоятельно.

##### Основные ошибки компоновки
1. Не найден символ (undefined symbols)
2. Найдено несколько символов с одним именем (multiple definition)

##### Защита от повторного включения
```c++
//buffer.h

namespace utils
{
    class Buffer
    {
         ...
    }
}
```
```c++
// text_processor.h
#include "buffer.h"

...
```
```c++
// main.cpp
#include "buffer.h"
#include "text_processor.h"
```
В одной единице трансляции два объявления класса `utils::Buffer`, компилятор не знает какое использовать.
```c++
// buffer.h
#ifndef UTILS_BUFFER_H
#define UTILS_BUFFER_H

...

#endif
```
```c++
// buffer.h
#pragma once
```

##### Циклическое включение

```c++
// a.h
#include "b.h"

class A
{
    B* b;
};
```

```c++
// b.h
#include "a.h"

class B
{
};
```

##### Предварительное объявление (forward declarations)

```c++
// a.h

class B;

class A
{
    B* b;
};
```

```c++
// a.cpp
#include "a.cpp"
```

```c++
// b.h
#include "a.h"

class B
{
};
```

### Функции
```c++
int rollDice()
{
    return 4;
}
```
```c++
void print(int x)
{
    std::cout << x << std::endl;
}
```

##### Перегрузка функций
```c++
void print(bool x)
{
    std::cout << (x ? "true" : "false") << std::endl;
}
```

##### Опасность перегрузки
```c++
void print(const std::string& x)
{
    std::cout << "string" << std::endl;
}

void print(bool x)
{
    std::cout << "bool" << std::endl;
}

print("hello!");

```

### Конвенции вызова для 32 бит
##### cdecl
Исторически принятое соглашение для языка С.

Аргументы функций передаются через стек, справа налево. Аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт. Очистку стека производит вызывающая программа.

Результат возвращается через регистры.

Перед вызовом функции вставляется код, называемый прологом (prolog) и выполняющий следующие действия:
- сохранение значений регистров, используемых внутри функции
- запись в стек аргументов функции

После вызова функции вставляется код, называемый эпилогом (epilog) и выполняющий следующие действия:
- восстановление значений регистров, сохранённых кодом пролога
- очистка стека (от локальных переменных функции)

##### thiscall
Соглашение о вызовах, используемое компиляторами для языка C++ при вызове методов классов.

Отличается от **cdecl** соглашения только тем, что указатель на объект, для которого вызывается метод (указатель this), записывается в регистр.

##### fastcall
Самый быстрый способ.

Передача параметров через регистры, если для сохранения всех параметров и промежуточных результатов регистров не достаточно, используется стек (в gcc через регистры передаются первые 2 параметра).

Соглашение не стандартизировано.

### Смотрим сгенерированный код
```c++
[[gnu::fastcall]]
void foo1(int x, int y, int z, int a)
{
}

void foo2(int x, int y, int z, int a)
{
}

void bar1()
{
    foo1(1, 2, 3, 4);
}

void bar2()
{
    foo2(5, 6, 7, 8);
}

int main()
{
}
```
```
g++ test.cpp -o test.o -O0 -m32
```
```
objdump -d test.o > test.txt
```
```
000005c8 <_Z4bar1v>:
 5c8:	6a 04                	push   $0x4
 5ca:	6a 03                	push   $0x3
 5cc:	ba 02 00 00 00       	mov    $0x2,%edx
 5d1:	b9 01 00 00 00       	mov    $0x1,%ecx
 5d6:	e8 b5 ff ff ff       	call   590 <_Z4foo1iiii>
 5dd:	c3                   	ret    

000005eb <_Z4bar2v>:
 5eb:	6a 08                	push   $0x8
 5ed:	6a 07                	push   $0x7
 5ef:	6a 06                	push   $0x6
 5f1:	6a 05                	push   $0x5
 5f3:	e8 b3 ff ff ff       	call   5ab <_Z4foo2iiii>
 5fd:	c3                   	ret   
```

### Конвенции вызова для 64 бит
- Спецефичны для платформы
- На x86-64 через регистры передаются 4 параматра, для С++ первый параметр при вызове метода - this

### Встраивание функций (inline)
```c++
inline void foo()
{
	...
}
```
> Компилятор умный и скорее всего проигнорирует inline, но можно попросить настойчивей

```c++
// ms vc
__forceinline void foo()
{
    ...
}
```
```c++
// gcc
__attribute__((always_inline)) void foo()
{
    ...
}
```
> Все равно нет гарантий

##### Тот случай когда макросы уместны
```c++
#ifdef __GNUC__
#define __forceinline __attribute__((always_inline))
#endif
```


### Передача аргументов в функции
#####  По значению
```c++
void foo(int x) { ... }
void bar(BigObject o) { ... }
```
- В функции окажется копия объекта, ее изменение не отразится на оригинальном объекте
- Копировать большие объекты может оказаться накладно

##### По ссылке
```c++
void foo(int& x) { ... }
void bar(BigObject& o) { ... }
```
- Копирования не происходит, все изменения объекта внутри функции отражаются на объекте
- Следует использовать, если надо изменить объект внутри функции

```c++
void swap(int& x, int& y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
```

##### По константной ссылке
```c++
void foo(const int& x) { ... }
void bar(const BigObject& o) { ... }
```
- Копирования не происходит, при попытке изменения объекта будет ошибка
- Большие объекты выгодней передавать по ссылке, маленькие - бессмысленно

##### По указателю
```c++
void foo(int* x) { ... }
void bar(BigObject* o) { ... }

void foo(const int* x) { ... }
void bar(const BigObject* o) { ... }
```
- Копирования не происходит
- Если указатель константный объект, то при попытке изменения объекта будет ошибка
- Есть дополнительный уровень косности, возможно придется что-то подгрузить из дальнего участка памяти
- Реализуется optional-концепция

```c++
int countObject(time_t* fromDate, time_t* toDate)
{
    const auto begin = 
        fromDate == nullptr
            ? objects_.findFirst(fromDate)
            : objects_.begin();

    ...
}
```

##### По универсальной ссылке
```c++
void foo(int&& x) { ... }
void bar(BigObject&& o) { ... }
```
Поговорим в отдельной лекции.

#### Указатель на функцию
```c++
void foo(int x)
{
    ...
}

typedef void (*FooPtr)(int);

FooPtr ptr = foo;

ptr(5);
```

```c++
using FooPtr = void(*)(int);
```

#### Функции высшего порядка
Функция высшего порядка — функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных.

```c++
using MoveFunctionPtr = void (*)(int& x, int& y);

void moveLeft(int& x, int& y) { ... }
void moveRight(int& x, int& y) { ... }

std::vector<MoveFunctionPtr> trajectory = 
    {
        moveLeft, 
        moveLeft, 
        moveRight, 
    };
```

#### std::function
```c++
using MoveFunction = std::function<void (int& x, int& y)>;

std::vector<MoveFunctionPtr> trajectory = 
    {
        moveLeft, 
        moveLeft, 
        moveRight, 
        [](int& x, int& y) 
        {
            ...
        },
        moveLeft
    };
```

### Практическая часть

Используя метод рекурсивного спуска написать простой калькулятор. Следует использовать функции, классы и переменные разделяемые между функциями использовать нельзя. Поддерживаемые операции:
- умножение
- деление
- сложение
- вычитание
- унарный минус

Калькулятор работает с целыми числами (int), приоритет операций стандартный. Передача выражения осуществляется через аргумент командной строки, результат выводится в cout. Пример:
```
calc "2 + 3 * 4 - -2"
```
Вывод:
```
16
```
##### Подсказки
```c++
int main(int argc, char* argv[])
{
    // argc - количество аргументов
    // argv - сами аргументы, первый всегда - имя программы
}
```
Грамматика калькулятора:
```
expr = term
    | expr + term
    | expr - term
term = prim
    | term * prim
    | term / prim
prim = number
    | -number
number = [0-9]+
```




EOF