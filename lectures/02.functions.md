# Компиляция и компоновка

### Препроцессор
##### Включение файла
```c++
#include <file_name> // Поиск в системных директориях
#include "file_name" // Поиск в текущей директории
```

##### Макроподстановки
```c++
#define true false // happy debugging
#define true !!(rand() % 2)
```
```c++
#define BUF_SIZE 1024
```
Не используйте define для определения констант, он игнорирует пространства имен и ничего не знает о типах.

###### Константы в С++
```c++
namespace options
{
    static const size_t BufSize = 1024;
    constexpr size_t BufSize = 1024;
}

std::array<char, options::BufSize> data;
```

##### Условная компиляция
```c++
#define DEBUG
#ifdef DEBUG
    ...
#else
    ...
#endif
```
```
g++ -DDEBUG ...
```

##### Вывод сообщений
```c++
#ifdef BUF_SIZE
#error Rename the macros
#endif

#define BUF_SIZE 256

...

#undef BUF_SIZE
```

### Единица трансляции
Минимальный блок исходного текста, который можно преобразовать во внутреннее машинное представление.

```code.cpp```
```c++
#include <vector>

#include "code.h"

void someFunction()
{
    ...
}

...
```
> Исходный код code.cpp, плюс все включенные в него файлы – единица трансляции.

```
g++ –o code.o –c code.cpp
```
code.o – результат компиляции, объектный файл (object file).

>При изменении любого включенного заголовочного файла потребуется перекомпиляция единицы трансляции.

### Компоновка (linking)
Объектный файл может ссылаться на символы не определенные в нем.

Объектные файлы собираются в исполняемый файл или библиотеку компоновщиком, не определенные символы компоновщик ищет в других объектных файлах и производит их замену на корректные адреса.

```
g++ -o my_app a.o b.o
```

Компоновщик ld, но g++ сделает его вызов самостоятельно.

##### Основные ошибки компоновки
1. Не найден символ (undefined symbols)
2. Найдено несколько символов с одним именем (multiple definition)

##### Защита от повторного включения
```c++
//buffer.h

namespace utils
{
    class Buffer
    {
         ...
    }
}
```
```c++
// text_processor.h
#include "buffer.h"

...
```
```c++
// main.cpp
#include "buffer.h"
#include "text_processor.h"
```
В одной единице трансляции два объявления класса `utils::Buffer`, компилятор не знает какое использовать.
```c++
// buffer.h
#ifndef UTILS_BUFFER_H
#define UTILS_BUFFER_H

...

#endif
```
```c++
// buffer.h
#pragma once
```

##### Циклическое включение

```c++
// a.h
#include "b.h"

class A
{
    B* b;
};
```

```c++
// b.h
#include "a.h"

class B
{
};
```

##### Предварительное объявление (forward declarations)

```c++
// a.h

class B;

class A
{
    B* b;
};
```

```c++
// a.cpp
#include "a.cpp"
```

```c++
// b.h
#include "a.h"

class B
{
};
```














