### Функтор (функциональный объект)

Объект ведущий себя подобно функции.

```c++
template <class T>
class Less
{
    const T x_;
private:
    Less(const T& x)
        : x_(x)
    {
    }

	bool operator()(const T& y) const
	{
		return x < y;
	}
};

Less less3(3);

bool lessThen5 = less3(5);
```

### Лямбда-функция

Краткая форма записи анонимных функторов.

```c++
auto less3 = [](int y) { return 3 < y; };

bool lessThen5 = less3(5);
```

#### Синтаксис лямбда-функции

```c++
[список_захвата](список_параметров) { тело_функции }
```
```c++
[список_захвата](список_параметров) mutable { тело_функции }
```
```c++
[список_захвата](список_параметров) -> тип_возвращаемого_значения
{ тело_функции }
```
```c++
[список_захвата](список_параметров) mutable -> тип_возвращаемого_значения
{ тело_функции }
```

Дополнительно для лямбды можно указать ```noexcept```

#### Захват переменных

```c++
int x = 5;
int y = 7;
auto foo = [x, &y]() { y = 2 * x };
foo();
```
```c++
// Захват всех переменных в области видимости по значению
auto foo = [=]() {};
```
```c++
// Захват всех переменных в области видимости по ссылке
auto foo = [&]() {};
```

Использование переменных, определённых в той же области видимости, что и лямбда-функция называют замыканием. 

##### Захват this

```c++
class A
{
    int x;
    void foo() {}
    void bar()
    {
        auto f = [this]()
        {
            foo();
            ++x;
        };
    }
};
```

##### Примеры захвата

```c++
[] // без захвата переменных из внешней области видимости
[=] // все переменные захватываются по значению
[&] // все переменные захватываются по ссылке
[x, y] // захват x и y по значению
[&x, &y] // захват x и y по ссылке
[in, &out] // захват in по значению, а out — по ссылке
[=, &out1, &out2] // захват всех переменных по значению,
// кроме out1 и out2, которые захватываются по ссылке
[&, x, &y] // захват всех переменных по ссылке, кроме x,
// которая захватывается по значению
```

##### mutable

```c++
int x = 3;
auto foo = [x]() mutable { x += 3; }
```

#### Вывод типа возвращаемого значения

```c++
// Возвращаемое значение типа int
auto sum = [](int x, int y) { return x + y; }
```
```c++
// Возвращаемое значение типа int
auto sum = [](int x, int y) -> double { return x + y; }
```

#### Лямбда - краткая форма анонимного функтора

```c++
int x = 3;
auto sum = [x](int y) { return x + y; };
auto s = sum(5);
```
```c++
class lambda__a123
{
    int x_;
public:
    explicit sum(int x)
        : x_(x)
    {
    }
    
    int operator()(int y) const
    {
        return x_ + y;
    }
};
auto sum = lambda__a123(3);
auto s = sum(5);
```

#### std::pair

Тип позволяющий упаковать два значения в один объект.

```c++
#include <utility>
 
auto p1 = std::pair<int, double>(1, 2.0);
auto p2 = std::make_pair(1, 2.0);
auto x = p1.first; // int == 1
auto y = p1.second; // double == 2
```

pair имеет операторы сравнения позволяющие сравнить содержимое поэлементно.

#### std::tuple

Тип позволяющий упаковать несколько значений в один объект.

```c++
#include <tuple>

auto t = std::make_tuple(1, 2.0, "abc");
int a = std::get<0>(t);
double b = std::get<1>(t);
std::string c = std::get<2>(t);
```

> Соответствие типов проверяется на этапе компиляции.

> Как и pair имеет операторы сравнения.

#### std::tie

Как и make_tuple создает tuple, но не объектов, а ссылок на них.

```c++
struct MyClass
{
    int x_;
    std::string y_;
    double z_;
    
    bool operator<(const MyClass& o) const
    {
        return std::tie(x_, y_, z_) < std::tie(o.x_, o.y_, o.z_);
    }
};
```

### Библиотека алгоритмов STL

1. Не изменяющие последовательные алгоритмы
2. Изменяющие последовательные алгоритмы
3. Алгоритмы сортировки
4. Бинарные алгоритмы поиска
5. Алгоритмы слияния
6. Кучи
7. Операции отношений

```c++
#include <algorithm>
```

#### Не изменяющие последовательные алгоритмы

Не изменяют содержимое последовательности и решают задачи поиска, подсчета элементов, установления равенства последовательностей.

##### adjacent_find

Возвращает итератор, указывающий на первую пару одинаковых объектов, если такой пары нет, то итератор - end.

```c++
std::vector<int> v { 1, 2, 3, 3, 4 };
auto i = std::adjacent_find(v.begin(), v.end());
```

##### all_of

Проверяет, что все элементы последовательности удовлетворяют предикату.

```c++
std::vector<int> v { 1, 2, 3, 4 };
if (std::all_of(v.begin(), v.end(), [](int x) { return x < 5; }))
    std::cout << "all elements are less than 5";
```

##### any_of

Проверяет, что хоть один элемент последовательности удовлетворяет предикату.

##### none_of

Проверяет, что все элементы последовательности не удовлетворяют предикату.

##### count, count_if

Возвращает количество элементов, значение которых равно value или удовлетворяет предикату.

```c++
std::vector<int> v { 3, 2, 3, 4 };
auto n = std::count(v.begin(), v.end(), 3); // n == 2
```

##### equal

Проверяет, что две последовательности идентичны.

```c++
bool isPalindrome(const std::string& s)
{
    return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
}

isPalindrome("level"); // true
```

Есть версия принимающая предикат.

##### find, find_if, find_if_not

Находит первый элемент последовательности удовлетворяющий условию.

##### find_end

Находит последний элемент последовательности удовлетворяющий условию.

##### find_first_of

Ищет в первой последовательности первое вхождение любого элемента из второй последовательности.

```c++
std::vector<int> v { 0, 2, 3, 25, 5 };
std::vector<int> t { 3, 19, 10, 2 };

auto result = std::find_first_of(v.begin(), v.end(), t.begin(), t.end());

if (result == v.end())
    std::cout << "no elements of v were equal to 3, 19, 10 or 2\n";
else
    std::cout << "found a match at "
        << std::distance(v.begin(), result) << "\n";
}

// found a match at 1
```

##### for_each

Применяет функцию ко всем элементам последовательности.

```c++
std::vector<int> v { 3, 2, 3, 4 };
auto print = [](int x) { std::cout << x; };
std::for_each(v.begin(), v.end(), print);
```

##### search

Ищет вхождение одной последовательности в другую последовательность.

##### search_n

Возвращает итератор на начало последовательности из n одинкаовых элементов или end.

##### mismatch

Возвращает пару итераторов на первое несовпадение элементов двух последовательностей.

```c++
std::vector<int> x { 1, 2 };
std::vector<int> y { 1, 2, 3, 4 };
auto pair = std::mismatch(x.begin(), x.end(), y.begin());
// pair.first == x.end()
// pair.second = y.begin() + 2
```

#### Модифицирующие последовательные алгоритмы

Изменяют содержимое последовательности, решают задачи копирования, замены, удаления, перестановки значений и т.д.





